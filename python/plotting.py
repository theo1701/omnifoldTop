"""
Functions to create OmniFold plots in some default styles.

Plotting styles
---------------

There are several dicts of keyword arguments setting global style for all
plots generated by this module (analogous to matplotlib's rcParams).
`hist_style`, `graph_style`, and `leg_style` set styles on histograms,
graphs, and legends, respectively. Where to look for documentation of the
options:

    hist_style  matplotlib.axes.Axes.hist
    graph_style matplotlib.axes.Axes.errorbar
    leg_style   matplotlib.axes.Axes.legend, plotting.draw_legend

The remainder (`data_style`, `sim_style`, `bkg_style`, `gen_style`,
`truth_style`, `ibu_style`, and `omnifold_style`) set styles for plotting
from specific datasets (for example, data is always plotted in orange with
the label "Data").
"""

import matplotlib
matplotlib.use('Agg')
import matplotlib.pyplot as plt

import numpy as np
import pandas as pd
import math

# for now
import external.OmniFold.modplot as modplot

from histogramming import calc_hist, get_hist, get_values_and_errors, set_hist_errors

from util import gaus, fit_gaussian_to_hist

from sklearn.metrics import roc_curve, auc, roc_auc_score
from sklearn.calibration import calibration_curve

# plotting styles
hist_style = {'histtype': 'step', 'density': False, 'lw': 1, 'zorder': 2}
graph_style = {'fmt': 'o', 'lw': 1.5, 'capsize': 1.5, 'capthick': 1, 'markersize': 1.5}
leg_style = {'handlelength': 2.0, 'loc': 'best', 'frameon': False, 'numpoints': 1, 'fontsize': 'small'}

data_style = {'color': 'black', 'label':  'Data', **hist_style}
sim_style = {'color': 'orange', 'label':  'Sim.', **hist_style}
bkg_style = {'color': 'cyan', 'label': 'Bkg.', **hist_style}

gen_style = {'linestyle': '--', 'color': 'blue', 'lw': 1.15, 'label': 'Gen.'}

truth_style = {'edgecolor': 'green', 'facecolor': (0.75, 0.875, 0.75), 'lw': 1.25, 'zorder': 0, 'label': 'Truth'}

ibu_style = {'ls': '-', 'marker': 'o', 'ms': 2.5, 'color': 'gray', 'zorder': 1, 'label':'IBU'}

omnifold_style = {'ls': '-', 'marker': 's', 'ms': 2.5, 'color': 'tab:red', 'zorder': 3, 'label':'MultiFold'}

def init_fig(title='', xlabel='', ylabel=''):
    """
    Set up a figure with a title and axis labels.

    Parameters
    ----------
    title : str, default: ""
    xlabel : str, default: ""
    ylabel : str, default: ""

    Returns
    -------
    matplotlib.figure.Figure, matplotlib.axes.Axes
    """
    fig, ax = plt.subplots()

    if title:
        ax.set_title(title)
    if xlabel:
        ax.set_xlabel(xlabel)
    if ylabel:
        ax.set_ylabel(ylabel)

    return fig, ax

def set_default_colors(ncolors):
    """
    Get up to the first `ncolors` of the default colour cycle.

    Parameters
    ----------
    ncolors : non-negative int

    Returns
    -------
    sequence of str
         The first `ncolors` items in the matplotlib colour cycle, as a
         sequence of 6-digit RGB hex strings (i.e. "#rrggbb"). Returns a
         number of colours equal to the shorter of (`ncolors`, length of
         the cycle).
    """
    return plt.rcParams['axes.prop_cycle'].by_key()['color'][:ncolors]

def draw_ratios(
        ax,
        histogram_denom,
        histograms_numer,
        color_denom_line='tomato',
        color_denom_fill='silver',
        colors_numer=None
):
    """
    Plot ratios of several numerator histograms to a denominator histogram.

    The denominator is plotted as a horizontal line at y = 1, with optional
    shaded rectangles to indicate the error bar for each bin. Numerators
    are drawn as points in the middle of the bin. If y error bars are
    provided, the x errors are +/- half the bin width.

    Parameters
    ----------
    ax : matplotlib.axes.Axes
    histogram_denom : Hist object.
        Histogram for the denominator.
    histograms_numer : sequence of Hist objects
        Each numerator is a sequence of histograms. num / denom will be
        plotted for each bin.
    color_denom_line : color, default: tomato
        Colour of the horizontal line at y = 1.
    color_denom_fill : color, default: silver
        Colour for denominator uncertainty.
    colors_numer : sequence of colors, optional
        Colour of each numerator series.

    See Also
    --------
    matplotlib.color : documentation of colours
    """

    bins = histogram_denom.axes[0].edges
    midbins = histogram_denom.axes[0].centers
    binwidths = histogram_denom.axes[0].widths

    # horizontal line at y=1
    ax.plot([np.min(bins), np.max(bins)], [1, 1], '-', color=color_denom_line, lw=0.75)

    hist_denom, hist_denom_unc = get_values_and_errors(histogram_denom)

    if hist_denom_unc is not None:
        denom_unc_ratio = np.divide(hist_denom_unc, hist_denom, out=np.zeros_like(hist_denom), where=(hist_denom!=0))
        denom_unc_ratio = np.append(denom_unc_ratio, denom_unc_ratio[-1])
        ax.fill_between(bins, 1-denom_unc_ratio, 1+denom_unc_ratio, facecolor=color_denom_fill, zorder=-2, step='post')

    if colors_numer is not None:
        assert(len(colors_numer)==len(histograms_numer))
    else:
        colors_numer = set_default_colors(len(histograms_numer))

    for i, histogram_num in enumerate(histograms_numer):
        if histogram_num is None:
            continue
        hist_num, hist_num_unc = get_values_and_errors(histogram_num)

        ymin, ymax = ax.get_ylim()
        ratio = np.divide(hist_num, hist_denom, out=np.ones_like(hist_denom)*ymin, where=(hist_denom!=0))

        ratio_unc = None
        if hist_num_unc is not None:
            ratio_unc = np.divide(hist_num_unc, hist_denom, out=np.zeros_like(hist_denom), where=(hist_denom!=0))

        ax.errorbar(midbins, ratio, xerr=binwidths/2, yerr=ratio_unc, color=colors_numer[i], **modplot.style('errorbar'))

def draw_legend(ax, legend_loc="best", legend_ncol=2, **config):
    """
    Add a legend to the axes.

    Parameters
    ----------
    ax : matplotlib.axes.Axes
    legend_loc : str or pair of floats, default: "best"
        Controls placement of the legend on the plot.
    legend_ncol : positive int, default: 2
        Number of columns in the legend.
    **config : dict, optional
        Additional keyword arguments (unused).

    See Also
    --------
    matplotlib.axes.Axes.legend :
        `legend_loc` and `legend_ncol` are equivalent to `loc` and `ncol`,
        respectively
    """
    modplot.legend(
        ax=ax,
        loc=legend_loc,
        ncol=legend_ncol,
        frameon=False,
        fontsize="x-small"
    )

def draw_stamp(ax, texts, x=0.5, y=0.5, dy=0.045):
    """
    Add a series of text to the axis, one line per text.

    Parameters
    ----------
    ax : matplotlib.axes.Axes
    texts : iterable of str
        Each item in the iterable will be drawn on its own line.
    x, y : float, default: 0.5
        Position of the text in data coordinates.
    dy : float, default: 0.045
        Separation between texts. Note that this will not set interline
        separation if a text includes a \n.
    """
    textopts = {'horizontalalignment': 'left',
                'verticalalignment': 'center',
                'fontsize': 5.,
                'transform': ax.transAxes}

    for i, txt in enumerate(texts):
        if txt is not None:
            ax.text(x, y-i*dy, txt, **textopts)

def draw_histogram(ax, histogram, **styles):
    """
    Plot a 1D histogram in the axes.

    Parameters
    ----------
    ax : matplotlib.axes.Axes
    histogram : Hist object
    **styles : dict, optional
        Additional keyword arguments passed to matplotlib.axes.Axes.hist
    """
    midbins = histogram.axes[0].centers
    bin_edges = histogram.axes[0].edges

    ax.hist(midbins, bin_edges, weights=histogram.values(), **styles)

def draw_stacked_histograms(ax, histograms, labels=None,
                            colors=None, stacked=True):
    """
    Plot 1D stacked histograms in the axes.

    Parameters
    ----------
    ax : matplotlib.axes.Axes
    histograms : sequence of Hist objects
        Sequence of histograms. Each item is the histogram for one dataset.
    labels : sequence of str, optional
        Label for each dataset. Must be the same length as `hists`. If not
        provided, the histograms will be numbered from 0.
    colors : sequence of colours, optional
        Colours of the histograms. Must be the same length as `hists`. If
        not provided, uses the standard line colour sequence.
    stacked : bool, default: True
        If True, histograms are stacked on top of each other. Otherwise
        histograms are arranged side-by-side.
    """
    midbins = histograms[0].axes[0].centers
    bin_edges = histograms[0].axes[0].edges

    if colors is None:
        colors = set_default_colors(len(histograms))
    assert(len(colors)==len(histograms))

    if labels is None:
        labels = [str(i) for i in range(len(histograms))]
    assert(len(labels)==len(histograms))

    ax.hist(np.stack([midbins]*len(histograms), axis=1), bin_edges,
            weights=np.stack([h.values() for h in histograms], axis=1),
            color=colors, label=labels,
            stacked = stacked, histtype='bar', fill=True)
    # TODO: uncertainty

def draw_hist_fill(ax, histogram, **styles):
    """
    Plot a filled 1D histogram in the axes.

    Parameters
    ----------
    ax : matplotlib.axes.Axes
    histogram : Hist object
    **styles : dict, optional
        Additional keyword arguments passed to matplotlib.axes.Axes.hist.
    """
    midbins = histogram.axes[0].centers
    bin_edges = histogram.axes[0].edges

    ax.hist(midbins, bin_edges, weights=histogram.values(), histtype='step', fill=True, **styles)
    # TODO: uncertainty?

def draw_hist_as_graph(ax, histogram, **styles):
    """
    Draw a histogram as a scatter plot with error bars.

    Parameters
    ----------
    ax : matplotlib.axes.Axes
    histogram : Hist object
    **styles : dict, optional
        Additional keyword arguments passed to matplotlib.axes.Axes.errorbar.

    Notes
    -----
    Points are plotted in the middle of each bin. If bin errors are plotted,
    the x error bars are set to +/- half the width of each bin.
    """
    midbins = histogram.axes[0].centers
    binwidths = histogram.axes[0].widths
    bin_edges = histogram.axes[0].edges

    hval, herr = get_values_and_errors(histogram)

    yerr = herr
    xerr = None if yerr is None else binwidths/2

    ax.errorbar(midbins, hval, xerr=xerr, yerr=yerr, **styles)

def plot_graphs(
        figname,
        data_arrays,
        error_arrays=None,
        labels=None,
        title='',
        xlabel='',
        ylabel='',
        xscale=None,
        yscale=None,
        colors=None,
        markers=None,
        **style
):
    """
    Create scatter plots of several data series on the same x and y axes.

    The generated figure is saved to "{figname}.png".

    Parameters
    ----------
    figname : str
        Path to save the figure, excluding the file extension.
    data_arrays : sequence of n (xdata, ydata) pairs where xdata, ydata are array-like
        Data positions to plot. Each element is one data series.
    error_arrays : sequence of n floats or 2-tuples, optional
        Error bars. Sequence of floats is interpreted as y error bars;
        2-tuples are interpreted as (x error bars, y error bars).
    labels : sequence of n str, optional
         Data series labels. If provided, the plot will contain a legend.
    title : str, default: ""
        Title of the figure.
    xlabel, ylabel : str, default: ""
        Axis labels.
    xscale, yscale : {"log", "log2"}, optional
        Set the axis scale to log base 10 or log base 2. If omitted, the
        axis is linear.
    colors : sequence of n colors, optional
        Line/marker colours for each data series. See also matplotlib.colors.
    markers : sequence of n str or matplotlib.markers.MarkerStyle, optional
        Marker style for each series. See also matplotlib.markers.
    **style : dict, optional
        Additional keyword arguments passed to matplotlib.axes.Axes.errorbar.
    """
    fig, ax = init_fig(title, xlabel, ylabel)

    if xscale=='log':
        ax.set_xscale('log')
    elif xscale=='log2':
        ax.set_xscale('log', basex=2)

    if yscale=='log':
        ax.set_yscale('log')
    elif yscale=='log2':
        ax.set_yscale('log', basey=2)

    if colors is None:
        colors = set_default_colors(len(data_arrays))
    else:
        assert(len(data_arrays)==len(colors))

    if error_arrays is not None:
        assert(len(error_arrays)==len(data_arrays))

    for i, (x, y) in enumerate(data_arrays):
        label = None if labels is None else labels[i]
        marker = None if markers is None else markers[i]
        color = colors[i%len(colors)]

        xerr, yerr = None, None
        if error_arrays is not None:
            error = error_arrays[i]
            if isinstance(error, tuple):
                xerr, yerr = error
            else:
                yerr = error

        ax.errorbar(x, y, xerr=xerr, yerr=yerr, label=label, marker=marker, color=color, **style)

    # plot legend if needed
    if labels is not None:
        ax.legend(**leg_style)

    fig.savefig(figname+'.png', dpi=300)
    #fig.savefig(figname+'.pdf')
    plt.close(fig)

def plot_histograms1d(
        figname,
        histograms,
        labels=None,
        title="",
        xlabel="",
        ylabel="",
        colors=None,
        plottypes=None,
        marker='o',
        yscale=None
):
    """
    Plot histograms of several datasets on the same x and y axes.

    The generated figure is saved to "{figname}.png".

    Parameters
    ----------
    figname : str
        Path to save the figure, excluding the file extension.
    histograms : list of Hist objects
        Sequence of histograms.
    labels : sequence of n str, optional
         Data series labels. If provided, the plot will contain a legend.
    title : str, default: ""
        Title of the figure.
    xlabel, ylabel : str, default: ""
        Axis labels.
    xscale, yscale : {"log", "log2"}, optional
        Set the axis scale to log base 10 or log base 2. If omitted, the
        axis is linear.
    colors : sequence of m colors, optional
        Line/marker colours for each data series. See also matplotlib.colors.
    plottypes : sequence of m {"g", "h"}, optional
        Plot a dataset as a graph (scatter plot) or histogram (bins). If
        not provided, uses histogram style.
    markers : str or matplotlib.markers.MarkerStyle, default: "o"
        Marker style for the histograms (only used when `plottype` is "g").
        See also matplotlib.markers.

    See Also
    --------
    plotting.draw_histogram, plotting.draw_hist_as_graph
    """
    fig, ax = init_fig(title, xlabel, ylabel)

    ax.xaxis.get_major_formatter().set_scientific(True)
    ax.xaxis.get_major_formatter().set_powerlimits((-3,4))

    if yscale=='log':
        ax.set_yscale('log')

    if colors is None:
        colors = set_default_colors(len(histograms))
    else:
        assert(len(colors)==len(histograms))

    if labels is None:
        labels = [""]*len(histograms)
    else:
        assert(len(labels)==len(histograms))

    if plottypes is None:
        plottypes = ['h']*len(histograms)
    else:
        assert(len(plottypes)==len(histograms))

    for i, h in enumerate(histograms):
        label = None if labels is None else labels[i]
        if plottypes[i] == "g":
            draw_hist_as_graph(ax, h, label=label, color=colors[i], marker=marker, **graph_style)
        elif plottypes[i] == "h":
            draw_histogram(ax, h, label=label, color=colors[i], fill=False, **hist_style)
        else:
            raise RuntimeError("Unknown plot type {}".format(plottypes[i]))

    # plot legend if needed
    if labels is not None:
        ax.legend(**leg_style)

    fig.savefig(figname+'.png', dpi=300)
    #fig.savefig(figname+'.pdf')
    plt.close(fig)

def plot_data_arrays(figname, data_arrs, weight_arrs=None, nbins=20, **plotstyle):
    """
    Plot a series of datasets as 1d histograms.

    Each dataset uses the same binning, which is evenly distributed across
    the full range of all combined datasets. The generated figure is saved
    to "{figname}.png".

    Parameters
    ----------
    figname : str
        Path to save the figure, excluding the file extension.
    data_arrs : sequence of n array-like
        Unbinned data.
    weight_arrs : sequence of n array-like, optional
        Each weight array should be the same shape as the corresponding
        data. Each data point contributes only its associated weight to the
        bin count instead of 1.
    nbins : positive int, default: 20
        Number of bins in the histogram.
    **plotstyle : dict, optional
        Additional keyword arguments passed to plotting.plot_histograms1d.
    """
    xmax = max([np.max(data) for data in data_arrs])
    xmin = min([np.min(data) for data in data_arrs])
    margin = (xmax - xmin) * 0.1
    bins = np.linspace(xmin-margin, xmax+margin, nbins+1)

    if weight_arrs is None:
        weight_arrs = [None] * len(data_arrs)
    else:
        assert(len(weight_arrs) == len(data_arrs))

    histograms = []
    for data, w in zip(data_arrs, weight_arrs):
        h = calc_hist(data, bins, weights=w, density=True)
        histograms.append(h)

    plot_histograms1d(figname, histograms, **plotstyle)

def plot_reco_variable(
        histogram_obs,
        histogram_sig,
        histogram_bkg=None,
        figname="var_reco",
        log_scale=False,
        yscale=None,
        **config
):
    """
    Plot detector-level variable distributions.

    Parameters
    ----------
    histogram_obs, histogram_sig, histogram_bkg : Hist objects
        Histograms for observables, signal, and
        background (optional), respectively.
    figname : str, default: "var_reco"
        Path to save the generated figure, excluding the file extension.
    log_scale : bool, default: False
        Use a log scale on the y axis.
    yscale : str, optional
        Sets the axis scale if `log_scale` is `False`.
    **config : dict, optional
        Additional keyword arguments passed to modplot.axes and plotting.draw_legend.
    """

    # use the plotting tools from the original omnifold package
    fig, axes = modplot.axes(ratio_plot=True, ylabel_ratio='Data \/\nMC', **config)
    ax0 = axes[0]
    ax1 = axes[1]

    # x limits
    bins = histogram_obs.axes[0].edges
    ax0.set_xlim(bins[0],bins[-1])
    ax1.set_xlim(bins[0],bins[-1])

    # yscale
    if log_scale:
        ax0.set_yscale('log')
    elif yscale is not None:
        ax0.set_yscale(yscale)

    # y limits
    ymax = max(histogram_obs.values().max(), histogram_sig.values().max())
    if histogram_bkg is not None:
        ymax = max(histogram_bkg.values().max(), ymax)

    ymin = 1e-4 if log_scale else 0
    ymax = ymax*10 if log_scale else ymax*1.2

    ax0.set_ylim(ymin, ymax*1.2)

    hists_stack = [histogram_sig]
    labels = [sim_style['label']]
    colors = [sim_style['color']]
    if histogram_bkg is not None:
        hists_stack = [histogram_bkg, histogram_sig]
        labels = [bkg_style['label'], sim_style['label']]
        colors = [bkg_style['color'], sim_style['color']]

    draw_stacked_histograms(ax0, hists_stack, labels=labels, colors=colors)
    draw_histogram(ax0, histogram_obs, **data_style)

    # data/mc ratio
    histogram_mc = histogram_sig if histogram_bkg is None else histogram_sig + histogram_bkg
    draw_ratios(ax1, histogram_mc, [histogram_obs], colors_numer=[data_style['color']])

    # legend
    draw_legend(ax0, **config)

    # save plot
    fig.savefig(figname+'.png', dpi=300, bbox_inches='tight')
    #fig.savefig(figname+'.pdf', bbox_inches='tight')

    plt.close(fig)

def plot_results(
        histogram_gen,
        histogram_of,
        histogram_ibu=None,
        histogram_truth=None,
        figname="unfolded",
        texts=[],
        yscale=None,
        draw_prior_ratio=False,
        stamp_xy=None,
        **config
):
    """
    Plot and compare the unfolded distributions.

    Parameters
    ----------
    histogram_gen, histogram_of, histogram_ibu, histogram_truth : Hist objects
        Histograms for generator, OmniFold, IBU (optional), and truth (optional) 
        distributions, respectively.
    figname : str, default: "unfolded"
        Path to save the generated figure, excluding the file extension.
    texts : sequence of str, default: []
        Additional text to draw on the axes.
    yscale : str, optional
    draw_prior_ratio, default: False
        If `True`, include the generator-level distribution in the ratio plot.
    stamp_xy : tuple of (float, float)
        Position of the additional text in data coordinates.
    **config : dict, optional
        Additional keyword arguments passed to modplot.axes and plotting.draw_legend.

    See Also
    --------
    plotting.draw_stamp : details of how `texts` are drawn
    """
    ymax = 0.

    # use the plotting tools from the original omnifold package
    truth_known = histogram_truth is not None
    fig, axes = modplot.axes(ratio_plot = truth_known, gridspec_update={'height_ratios': (3.5,2) if truth_known else (1,)}, **config)

    # set xaxis limit according to bin edges
    bin_edges = histogram_gen.axes[0].edges
    for ax in axes:
        ax.set_xlim(bin_edges[0], bin_edges[-1])

    ax0 = axes[0]
    ax1 = axes[1] if truth_known else None

    if yscale is not None:
        ax0.set_yscale(yscale)

    # generator-level
    # signal prior
    ymax = max(histogram_gen.values().max(), ymax)
    draw_hist_as_graph(ax0, histogram_gen, **gen_style)

    # if truth is known
    if histogram_truth is not None:
        ymax = max(histogram_truth.values().max(), ymax)
        draw_hist_fill(ax0, histogram_truth, **truth_style)

    # unfolded distributions
    # omnifold
    ymax = max(histogram_of.values().max(), ymax)
    draw_hist_as_graph(ax0, histogram_of, **omnifold_style)

    # iterative Bayesian unfolding
    if histogram_ibu is not None:
        ymax = max(histogram_ibu.values().max(), ymax)
        draw_hist_as_graph(ax0, histogram_ibu, **ibu_style)

    # update y-axis limit
    ax0.set_ylim((0, ymax*1.2))

    if ax1:
        #  ratios of the unfolded distributions to truth
        hists_numerator = [histogram_ibu, histogram_of]
        colors_numerator = [ibu_style['color'], omnifold_style['color']]
        if draw_prior_ratio:
            hists_numerator = [histogram_gen] + hists_numerator
            colors_numerator = [gen_style['color']] + colors_numerator

        draw_ratios(ax1, histogram_truth, hists_numerator,
                    color_denom_line = truth_style['edgecolor'],
                    color_denom_fill= truth_style['facecolor'],
                    colors_numer = colors_numerator)

    draw_legend(ax0, **config)

    draw_stamp(ax0, texts, stamp_xy[0], stamp_xy[1])

    # save plot
    fig.savefig(figname+'.png', dpi=300, bbox_inches='tight')
    #fig.savefig(figname+'.pdf', bbox_inches='tight')

    plt.close(fig)

def plot_response(figname, histogram2d, variable):
    """
    Plot the unfolded detector response matrix.

    Parameters
    ----------
    figname : str
        Path to save the generated figure, excluding the file extension.
    histogram2d :Hist object. 2D histogram.
        Detector response matrix. Entries are percentages in the range [0, 1].
    variable : str
        Name of the plotted variable.
    """
    h2d = histogram2d.values()
    xedges = histogram2d.axes[0].edges
    yedges = histogram2d.axes[1].edges

    fig, ax = init_fig(
        title='Detector Response',
        xlabel='Detector-level {}'.format(variable),
        ylabel='Truth-level {}'.format(variable)
    )
    X, Y = np.meshgrid(xedges, yedges)
    im = ax.pcolormesh(X, Y, h2d.T*100, cmap='Greens')
    fig.colorbar(im, ax=ax, label="%")

    # label bin content
    xcenter =(xedges[:-1]+xedges[1:])/2
    ycenter = (yedges[:-1]+yedges[1:])/2
    for i, xc in enumerate(xcenter):
        for j, yc in enumerate(ycenter):
            bin_content = round(h2d[i, j]*100)
            if bin_content != 0:
                ax.text(xc, yc, str(int(bin_content)), ha='center', va='center', fontsize=3)

    fig.savefig(figname+'.png', dpi=300)
    #fig.savefig(figname+'.pdf')
    plt.close(fig)

def plot_iteration_distributions(
        figname,
        histograms,
        histogram_truth=None,
        nhistmax=7,
        yscale=None,
        **config
):
    """
    Plot intermediate unfolded distributions of all iterations.

    Parameters
    ----------
    figname : str
        Path to save the generated figure, excluding the file extension.
    histograms : sequence of Hist objects
        Histograms of unfolding at each iteration.
    histogram_truth : Hist object
        Histogram of the truth distribution.
    nhistmax : int <= 10, default: 7
        Plot at most this many histograms.
    **config : dict, optional
        Additional keyword arguments passed to modplot.axes and plotting.draw_legend
    """
    binedges = histograms[0].axes[0].edges
    fig, axes = modplot.axes(ratio_plot=True, gridspec_update={'height_ratios': (3.5,2)}, **config)
    for ax in axes:
        ax.set_xlim(binedges[0], binedges[-1])

    ax0 = axes[0]

    if yscale is not None:
        ax0.set_yscale(yscale)

    # if there are more than nhistmax histograms, plot at most nhistmax histograms
    assert(nhistmax<=10) # plt.rcParams['axes.prop_cycle'] provides max 10 colors
    if len(histograms) > nhistmax:
        selected_i = np.linspace(1, len(histograms)-2, nhistmax-2).astype(int).tolist()
        # the first [0] and the last [-1] are always plotted
        selected_i = [0] + selected_i + [len(histograms)-1]
    else:
        selected_i = list(range(len(histograms)))

    histograms_toplot = [histograms[i] for i in selected_i]

    styles = ibu_style.copy()
    colors = set_default_colors(len(selected_i))

    ymax = 0.
    for i, h, color in zip(selected_i, histograms_toplot, colors):
        styles.update({'color': color, 'label': 'iteration {}'.format(i)})
        ymax = max(h.values().max(), ymax)
        draw_hist_as_graph(ax0, h, alpha=0.8, **styles)

    # set yaxis range
    ax0.set_ylim((0, ymax*1.2))

    # ratio
    if histogram_truth is not None:
        axes[1].set_ylabel("Ratio to Truth", fontsize=8)
        # Draw ratio to truth
        draw_ratios(axes[1], histogram_truth, histograms_toplot,
                    color_denom_line = 'black', colors_numer = colors)
    else:
        # Draw ratio to prior
        axes[1].set_ylabel("Ratio to Prior", fontsize=8)
        draw_ratios(axes[1], histograms_toplot[0], histograms_toplot[1:],
                    color_denom_line = colors[0], colors_numer = colors[1:])

    draw_legend(ax0, **config)

    # save plot
    fig.savefig(figname+'.png', dpi=200, bbox_inches='tight')
    plt.close(fig)

def plot_train_loss(figname, loss, val_loss):
    """
    Generate a plot of training losses vs. epoch.

    Parameters
    ----------
    figname : str
        Path to save the figure, excluding the file extension.
    loss : array-like
        History of the loss on the training set while training the model.
    val_loss : array-like
        History of the loss on the validation set while training the model.
    """
    fig, ax = init_fig(title='', xlabel='Epochs', ylabel='loss')

    ax.plot(loss, label='loss')
    ax.plot(val_loss, label='val loss')

    ax.yaxis.get_major_formatter().set_useOffset(False)
    ax.yaxis.get_major_formatter().set_useMathText(True)
    ax.yaxis.get_major_formatter().set_scientific(True)
    ax.yaxis.get_major_formatter().set_powerlimits((-3,4))

    ax.legend(**leg_style)

    plt.savefig(figname+'.png', dpi=300, bbox_inches='tight')
    #plt.savefig(plot_name+'.pdf', bbox_inches='tight')
    plt.close(fig)

def plot_train_log(csv_file, plot_name=None):
    """
    Generate a plot of training loss from a training history file.

    Parameters
    ----------
    csv_file : str
        Path to the training history CSV file.
    plot_name : str, optional
        Path to save the figure, excluding the file extension. If omitted,
        the generated figure will have the same name as the input file with
        the file extension replaced.
    """
    df = pd.read_csv(csv_file)

    if plot_name is None:
        plot_name = csv_file.replace('.csv', '_loss')

    plot_train_loss(plot_name, df['loss'], df['val_loss'])

def plot_correlations(correlations, figname):
    """
    Generate inter-bin correlation plot.

    Parameters
    ----------
    correlations : (n, n) array-like
        The correlation matrix between bins in a histogram.
    figname : str
        Path to save the figure, excluding the file extension.
    """
    fig, ax = plt.subplots()
    im = ax.imshow(correlations, vmin=-1, vmax=1, cmap='coolwarm')
    fig.colorbar(im, ax=ax)
    ax.tick_params(axis='both', labelsize='small')
    ax.tick_params(axis='x', top=True, labeltop=True, bottom=False, labelbottom=False, labelrotation=30)
    ticks = np.arange(0, len(correlations), 1)
    ax.set_xticks(ticks)
    ax.set_yticks(ticks)
    ax.set_xticklabels(correlations.columns)
    ax.set_yticklabels(correlations.columns)

    fig.savefig(figname+'.png', dpi=200)
    #fig.savefig(figname+'.pdf')

    plt.close(fig)

def plot_LR_distr(figname, ratios, labels=None):
    """
    Plot the distribution of likelihood ratios.

    Parameters
    ----------
    figname : str
        Path to save the figure, excluding the file extension.
    ratios : sequence of array-like
        Datasets of unbinned likelihood ratios.
    labels : sequence of str, optional
        Labels for each set of likelihood ratios in `ratios`.
    """
    bins_r = np.linspace(min(r.min() for r in ratios)*0.9, max(r.max() for r in ratios)*1.1, 50)

    histograms = []
    for r in ratios:
        hr = calc_hist(r, bins_r, density=False )
        histograms.append(hr)

    plot_histograms1d(figname, histograms, labels, xlabel='r')#, yscale='log')

def plot_training_vs_validation(
        figname,
        predictions_train,
        labels_train,
        weights_train,
        predictions_val,
        labels_val,
        weights_val,
        nbins=100
):
    """
    Compare the model's performance on the training vs. validation set

    Parameters
    ----------
    figname : str
        Path to save the figure, excluding the file extension.
    predictions_train : (n_pred,) array-like of floats in [0, 1]
        Probability that each event in the training set is in category 1.
    labels_train : (n_pred,) or (n_pred, m) array-like
        Labels for events in the test set, either as a 1d array or categorical.
    weights_train : (n_pred,) array-like
        Weight per event in the training set. Each event contributes its
        associated weight to its bin instead of 1.
    predictions_val : (n_val,) array-like of floats in [0, 1]
        Probability that each event in the validation set is in category 1.
    labels_val : (n_val,) or (n_val, m) array-like
        Labels for events in the validation set, either as a 1d array or categorical.
    weights_val : (n_val,) array-like
        Weight per event in the validation set. Each event contributes its
        associated weight to its bin instead of 1.
    nbins : positive int, default: 100
        Number of bins in the generated histogram.
    """
    # determine bins of histograms to plot
    bins_min = math.floor(min(predictions_train.min(), predictions_val.min())*10)/10
    bins_max = math.ceil(max(predictions_train.max(), predictions_val.max())*10)/10
    bins_preds = np.linspace(bins_min, bins_max, nbins)

    if labels_train.ndim == 1: # label array is simply a 1D array
        preds_cat1_t = predictions_train[labels_train==1]
        preds_cat0_t = predictions_train[labels_train==0]
        w_cat1_t = weights_train[labels_train==1]
        w_cat0_t = weights_train[labels_train==0]
    else: # label array is categorical
        preds_cat1_t = predictions_train[labels_train.argmax(axis=1)==1]
        preds_cat0_t = predictions_train[labels_train.argmax(axis=1)==0]
        w_cat1_t = weights_train[labels_train.argmax(axis=1)==1]
        w_cat0_t = weights_train[labels_train.argmax(axis=1)==0]

    hist_preds_cat1_t = calc_hist(preds_cat1_t, bins_preds, weights=w_cat1_t, density=True)
    hist_preds_cat0_t = calc_hist(preds_cat0_t, bins_preds, weights=w_cat0_t, density=True)

    # validation data
    if labels_val.ndim == 1: # label array is simply a 1D array
        preds_cat1_v = predictions_val[labels_val==1]
        preds_cat0_v = predictions_val[labels_val==0]
        w_cat1_v = weights_val[labels_val==1]
        w_cat0_v = weights_val[labels_val==0]
    else: # label array is categorical
        preds_cat1_v = predictions_val[labels_val.argmax(axis=1)==1]
        preds_cat0_v = predictions_val[labels_val.argmax(axis=1)==0]
        w_cat1_v = weights_val[labels_val.argmax(axis=1)==1]
        w_cat0_v = weights_val[labels_val.argmax(axis=1)==0]

    hist_preds_cat1_v = calc_hist(preds_cat1_v, bins_preds, weights=w_cat1_v, density=True)
    hist_preds_cat0_v = calc_hist(preds_cat0_v, bins_preds, weights=w_cat0_v, density=True)

    plot_histograms1d(figname,
        [hist_preds_cat1_t, hist_preds_cat0_t, hist_preds_cat1_v, hist_preds_cat0_v],
        labels=['y = 1 (training)', 'y = 0 (training)', 'y = 1 (validation)', 'y = 0 (validation)'],
        xlabel = 'Prediction (y = 1)',  plottypes=['h','h','g','g'], marker='+')

def plot_hists_resamples(figname, histograms, hist_prior, hist_truth=None,
                         **config):
    """
    Generate a plot of the results of several resamples of the unfolding problem.

    Parameters
    ----------
    figname : str
        Path to save the figure, excluding the file extension.
    bins : (n,) array-like
        Locations of the bin edges of the histogram.
    histograms : sequence of array-likes of shape (n - 1,)
        Unfolded distributions for each resample, binned according to `bins`.
    hist_prior : (n - 1,) array-like
        Histogram of the prior distribution binned according to `bins`.
    hist_truth : (n - 1,) array-like, optional
        Histogram of the truth distribution binned according to `bins`.
    **config : dict, optional
        Additional keyword arguments passed to modplot.axes and plotting.draw_legend.
    """
    fig, axes = modplot.axes(ratio_plot=True, ylabel_ratio='Ratio to\nPrior', **config)
    # set x axis limit
    bins = hist_prior.axes[0].edges
    for ax in axes:
        ax.set_xlim(bins[0], bins[-1])
    ax0, ax1 = axes

    ymax=0
    alpha=0.5
    for i, h in enumerate(histograms):
        ymax = max(h.values().max(), ymax)
        color=tuple(np.random.random(3))+(alpha,)
        label='Rerun' if i==0 else None
        draw_hist_as_graph(ax0, h, ls='--', lw=1, color=color, label=label)

    # mean of each bin
    hmean = np.mean(np.asarray(histograms)['value'], axis=0)
    hist_mean = get_hist(bins, hmean)
    draw_hist_as_graph(ax0, hist_mean, ls='-', lw=1, color='black', label='Mean')

    # the prior distribution
    draw_hist_as_graph(ax0, hist_prior, ls='-', lw=1, color='blue', label='Prior')
    ymax = max(hist_prior.values().max(), ymax)

    # the truth distribution
    if hist_truth is not None:
        draw_hist_as_graph(ax0, hist_truth, ls='-', lw=1, color='green', label='Truth')
        ymax = max(hist_truth.values().max(), ymax)

    ax0.set_ylim(0, ymax*1.2)

    # standard deviation of each bin
    hist_std = np.std(np.asarray(histograms)['value'], axis=0, ddof=1)
    # set it as the uncertainty of the mean distribution
    set_hist_errors(hist_mean, hist_std)

    # ratio
    if hist_truth is None:
        draw_ratios(ax1, hist_prior, [hist_mean], colors_numer=['black'], color_denom_line='blue')
    else:
        # draw ratio to truth
        ax1.set_ylabel("Ratio to\nTruth", fontsize=8)
        draw_ratios(ax1, hist_truth, [hist_mean], colors_numer=['black'], color_denom_line='green')

    draw_legend(ax0, **config)

    # save plot
    fig.savefig(figname+'.png', dpi=200, bbox_inches='tight')
    plt.close(fig)

def plot_hists_bin_distr(figname, histograms_list, histogram_ref):
    # histograms_list can be either dimension 3 if all iterations are included
    # or dimension 2 if only the final unfolded ones for all trials
    histograms_arr = np.asarray(histograms_list)['value']

    nbins = histogram_ref.axes[0].size
    niterations = histograms_arr.shape[1] if histograms_arr.ndim > 2 else 1

    fig, ax = plt.subplots(nrows=niterations, ncols=nbins,
                            sharey='row', sharex='col',
                            figsize=((nbins+1)*1.1, niterations*1.1),
                            constrained_layout=True)

    # loop over bins
    for ibin in range(nbins):
        nentries = histograms_arr[..., ibin]
        # nentries is of the shape (nresamples, niterations) if include iteration history
        # otherwise it is of the shape (nresamples,)

        #mu = np.mean(nentries, axis=0)
        #sigma = np.std(nentries, ddof=1, axis=0)
        #pulls = (nentries - mu) / sigma

        # compare and standardize to ref
        ref = histogram_ref.values()[ibin]
        nentries_ref = nentries - ref

        # plot
        if niterations == 1: # only the final results
            h, b = ax[ibin].hist(nentries_ref, density=True)[:2]
            plot_gaussian(ax[ibin], h, b, dofit=False)
            ax[ibin].set_xlabel("Bin {}".format(ibin+1))
            ax[ibin].xaxis.set_label_position('top')
            ax[ibin].tick_params(labelsize=7)
            ax[ibin].ticklabel_format(style='sci', scilimits=(-2,2), useMathText=True)
            ax[ibin].xaxis.get_offset_text().set_fontsize(7)
        else: # all iterations
            for it in range(niterations):
                h, b = ax[it][ibin].hist(nentries_ref[...,it], density=False)[:2]
                plot_gaussian(ax[it][ibin], h, b, dofit=False)
                # labels
                if ibin == 0:
                    ax[it][ibin].set_ylabel("Iter {}".format(it+1))
                if it == 0:
                    ax[it][ibin].set_xlabel("Bin {}".format(ibin+1))
                    ax[it][ibin].xaxis.set_label_position('top')
                ax[it][ibin].tick_params(labelsize=7)
                ax[it][ibin].ticklabel_format(style='sci', scilimits=(-2,2), useMathText=True)
                ax[it][ibin].xaxis.get_offset_text().set_fontsize(7)

    fig.savefig(figname+'.png', dpi=200, bbox_inches='tight')
    plt.close(fig)

def plot_gaussian(ax, histogram, binedges, dofit=False):
    """
    Draw a Gaussian fit to a histogram on the axes.

    Parameters
    ----------
    ax : matplotlib.axes.Axes
    histogram : (n,) array-like
        Bin heights in a histogram.
    binedges : (n + 1,) array-like
        Location of bin edges for `histogram`.
    dofit : bool, default: False
        If True, fit the Gaussian to the histogram using least-squares. If
        False, use a Gaussian with the same mean, standard deviation, and
        maximum as the histogram.
    """
    A, mu, sigma = fit_gaussian_to_hist(histogram, binedges, dofit)

    x = np.linspace(binedges[0], binedges[-1], 50)
    y = gaus(x, A, mu, sigma)
    style = '-' if dofit else '--'
    ax.plot(x, y, style)

    #yref = gaus(x, sum(histogram)/math.sqrt(2*math.pi), 0, 1)
    #ax.plot(x, yref, '--')

def plot_roc_curves(figname, Y_predicts, Y_true, weights, labels=None):
    """
    Generate a receiver operating curve for several classifiers.

    Parameters
    ----------
    figname : str
        Path to save the figure, excluding the file extension.
    Y_predicts : sequence of array-like of shape (n,)
        Each sequence is the predicted binary labels on the same set of
        samples for different classifiers.
    Y_true : (n,) array-like
        Correct binary labels for each sample.
    weights : (n,) array-like
        Weights for each sample.
    labels : sequence of str, optional
        If provided, labels for each classifier.

    See Also
    --------
    sklearn.metrics.roc_curve
    """
    if labels is None:
        labels = [''] * len(Y_predicts)
    else:
        assert(len(Y_predicts)==len(labels))

    fig, ax = init_fig(title='ROC curve', xlabel='False positive rate', ylabel='True positive rate')
    ax.set_xlim(0.0, 1.0)
    ax.set_ylim(0.0, 1.0)
    ax.grid()

    for Y_pred, label in zip(Y_predicts, labels):
        fpr, tpr, threshold = roc_curve(Y_true, Y_pred, sample_weight=weights)
        try:
            auroc = roc_auc_score(Y_true, Y_pred, sample_weight=weights)
        except ValueError as ve:
            print("ValueError: {}".format(ve))
            # sort
            idx = np.argsort(fpr)
            fpr = fpr[idx]
            tpr = tpr[idx]
            auroc = auc(fpr, tpr)

        ax.plot(fpr, tpr, lw=1, label='{} (auc = {:.3f})'.format(label, auroc))
        ax.legend()

    fig.savefig(figname+'.png', dpi=300)
    plt.close(fig)

def plot_calibrations(figname, Y_predicts, Y_true, labels=None):
    """
    Parameters
    ----------
    figname : str
        Path to save the figure, excluding the file extension.
    Y_predicts : sequence of array-like of shape (n,)
        Each sequence is the predicted probability of the positive class on
        the same set of samples for different classifiers.
    Y_true : (n,) array-like
        Correct binary labels for each sample.
    labels : sequence of str, optional
        If provided, labels for each classifier.

    See Also
    --------
    sklearn.metrics.calibration_curve
    """

    if labels is None:
        labels = [''] * len(Y_predicts)
    else:
        assert(len(Y_predicts)==len(labels))

    fig, ax = init_fig(title='Reliability curve', xlabel='Mean predicted value', ylabel='Fraction of positives')
    ax.set_xlim(0.0, 1.0)
    ax.set_ylim(0.0, 1.0)
    ax.grid()

    for Y_pred, label in zip(Y_predicts, labels):
        fraction_of_positives, mean_predicted_value = calibration_curve(Y_true, Y_pred, n_bins=10)
        ax.plot(mean_predicted_value, fraction_of_positives, "s-", label=label)
        ax.legend()

    fig.savefig(figname+'.png', dpi=300)
    plt.close(fig)
